# 原定计划 #

  * (Week6-Week7) 实现将最简单的”hello world”搬上ucore。包含了内存管理、读写支持runtime的具体实现

# 项目进展 #

  1. 对交叉编译环境进行了一定的改进，使得交叉编译更顺利进行；
  1. 用Python编写了自动化编译脚本。在修改了go或者ucore时，只需要一条指令就能将二者改动的地方重新编译并整合起来，加快调试速度；
  1. 初步明确并实现了装载LDT的解决方法，能够在ucore中通过go程序的相关代码段；
  1. 开始对mmap和munmap进行一定的尝试。

# 实现分析 #

  1. 原来我们一直在考虑go的makefile进行原生的交叉编译执行。实际上只需要在linux编译出纯linux的编译器后，将runtime改成ucore系统执行部分编译就能完成交叉编译；
  1. LDT一开始我们有两种意见：一是根据裸机go程序的相关实现tiny，认为只需要在GDT中加入伪LDT表即可，另一种是将linux中的相关代码移植进来。由于前者实现起来更简单，并且也有成熟的示例，我们最终使用这种方法，使得LDT成功装载，并且读写也得以正常进行。
  1. 在LDT设置的过程中，地址的设定着实让我们费了很大功夫。因为根据go语言中的注释，pthread在创建线程后通过GS段读取内存时，会有+8的偏移，而其他实现则没有偏移。为了统一这种差异，go的链接器8l统一将所有相关的偏移-8，然后通过一些与操作系统相关的宏控制不同系统上的偏移。在ucore上，我们进行了一定的调试，最终使得ldt的装载能通过go程序的相关内存自检。
  1. 内存方面，我们将go的runtime中对mmap和munmap的调用进行了更改，使之符合ucore调用。目前系统能够通过相关的分配。
  1. go语言中的printf和相关打印操作全部通过文件系统的write来实现。我们将write的调用改成适合ucore的模式（调换寄存器顺序）。

# 问题描述 #

  1. 现在程序似乎对于g和m两个关键的程序线程描述表并没有正确的加载，以至于从其中读出的指针数据并不像是正常的指针。对于这个问题，我们可能需要对如下部分进行排查：1、LDT是否确实正确装载？2、在利用mmap分配更多栈上空间时，mmap是否正常完成了工作。3、g和m描述表的指针地址是否指向正确的地方？

# 下一步工作 #

  1. 继续排查内存方面的错误，争取尽快将“Hello World”跑起来。
  1. 开始线程方面的相关工作，将runtime中对clone的调用在ucore上调通。






